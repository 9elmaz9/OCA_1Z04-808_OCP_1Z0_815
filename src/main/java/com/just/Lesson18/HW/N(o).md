# Что такое O(n²)?

## Описание
O(n log n): Понимание на практике
Когда мы говорим о сложности алгоритма O(n log n), это значит, что время выполнения алгоритма растет не просто пропорционально количеству элементов в данных (как в случае с O(n)), а немного быстрее. Однако O(n log n) — это всё ещё достаточно быстро и эффективно по сравнению с такими алгоритмами, как O(n²), которые значительно медленнее.

Что такое O(n log n)?
##  O(n) — это просто «один раз пройти по всем данным». Если у вас 100 элементов, вы делаете 100 операций. Логично, да?

##  O(log n) — это «процесс, в котором количество операций растет медленно, даже если данные увеличиваются». Это как если бы вы делали шаги, но с каждым шагом увеличивали бы шаг в два раза.

Когда мы комбинируем эти два, получается O(n log n), что работает значительно быстрее, чем O(n²) для больших данных.

**O(n²)** — это обозначение времени работы алгоритма, которое означает, что время выполнения алгоритма растет **квадратично** с увеличением размера входных данных. Это типичный пример **квадратичной сложности** (quadratic complexity).

В **O(n²)** сложность алгоритма растет с квадратичным увеличением количества элементов. То есть, если размер входных данных увеличивается в два раза, количество операций увеличится в четыре раза.

Этот тип сложности часто встречается в простых, но неэффективных алгоритмах сортировки, таких как **сортировка пузырьком** (Bubble Sort) или **сортировка выбором** (Selection Sort).

## Пример

Представьте, что у вас есть массив из **n** элементов. В алгоритме с **O(n²)** вам нужно выполнить операции, сравнивая каждый элемент с каждым другим. Это значит, что для каждого элемента вы будете выполнять сравнение с остальными **n-1** элементами.

Таким образом, общее количество операций будет равно **n × n = n²**.

Пример:

Если у вас есть массив из 3 элементов, то вам нужно выполнить **9** операций (3 * 3):

``` java
{5, 8, 1}
 ```
Сравнение 5 с 8, 5 с 1
Сравнение 8 с 5, 8 с 1
Сравнение 1 с 5, 1 с 8
Это дает 9 операций для 3 элементов.

Если размер массива увеличится до 10 элементов, количество операций будет уже 100 (10 * 10).

Примеры алгоритмов с O(n²)
Сортировка пузырьком (Bubble Sort)

Алгоритм сортировки пузырьком проходит по массиву и сравнивает каждый элемент с соседним. Если элементы находятся в неправильном порядке, они меняются местами. Этот процесс повторяется до тех пор, пока весь массив не станет отсортированным.

Поскольку для каждого элемента требуется пройтись по всем остальным элементам, его сложность — O(n²).

Пример кода сортировки пузырьком:

java
Copy code
public class BubbleSort {
    public static void bubbleSort(int[] array) {
        int n = array.length;
        for (int i = 0; i < n - 1; i++) {
            for (int j = 0; j < n - 1 - i; j++) {
                if (array[j] > array[j + 1]) {
                    // Обмен местами
                    int temp = array[j];
                    array[j] = array[j + 1];
                    array[j + 1] = temp;
                }
            }
        }
    }

    public static void main(String[] args) {
        int[] array = {5, 8, 1, -3, 0, 8, 2, 2};
        bubbleSort(array); // Сортировка массива
        for (int num : array) {
            System.out.println(num); // Вывод отсортированного массива
        }
    }
}
Сортировка выбором (Selection Sort)

В этом алгоритме мы находим минимальный элемент в массиве и меняем его с первым элементом. Затем повторяем это для оставшихся элементов.

Поскольку для каждого элемента нужно пройти весь оставшийся массив, сложность алгоритма — O(n²).

Почему O(n²) медленно?
Когда алгоритм имеет сложность O(n²), это означает, что количество операций растет быстро с увеличением размера данных. Например, если размер данных увеличивается в два раза, количество операций увеличивается в четыре раза. Это делает такие алгоритмы менее эффективными для больших наборов данных.

Пример сравнения:
Если у вас есть 100 элементов, алгоритм с O(n²) выполнит около 10,000 операций.
Если размер данных увеличится до 1,000 элементов, то количество операций станет 1,000,000.
Сравнение с O(n log n):

Алгоритмы с O(n log n) растут значительно медленнее и справляются с большим объемом данных гораздо быстрее.
Когда использовать O(n²)?
Алгоритмы с O(n²) могут быть полезны для небольших наборов данных, когда производительность не является критичной. Однако для больших данных они становятся неэффективными. В таких случаях стоит рассматривать более быстрые алгоритмы, такие как сортировка слиянием (Merge Sort) или быстрая сортировка (Quick Sort), которые имеют сложность O(n log n).

Заключение
O(n²) — это сложность алгоритмов, которые выполняют много операций для каждого элемента данных. Это типичная сложность для простых сортировок, таких как сортировка пузырьком и сортировка выбором. Эти алгоритмы менее эффективны для больших наборов данных, и лучше использовать более быстрые алгоритмы с O(n log n).